<!DOCTYPE html>
<meta charset="utf-8">
<style>

.station {
  stroke: #000;
  stroke-width: 0.0px;
  fill: #00d;
  fill-opacity: 0.2;
}

.route {
  stroke: #999;
  stroke-opacity: .7;
  stroke-width: 1px;
}

.event {
  stroke: #000;
  stroke-width: 0.5px;
  fill: #d00;
}

.trip {
  stroke: #000;
  stroke-width: 0.5px;
}

body {
  margin: 0;
}

path {
  fill: none;
  stroke: #000;
  stroke-linejoin: round;
  stroke-linecap: round;
}

.major_road { stroke: #776; stroke-opacity: .4;}
.minor_road { stroke: #ccb; stroke-opacity: .4;}
.highway { stroke: #669; stroke-width: 1.2px; stroke-opacity: .4;}
.rail { stroke: #7de; stroke-opacity: .4;}
</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/d3.geo.tile.v0.min.js"></script>
<script src="../colorbrewer.js"></script>
<script>

var width = 960,
    height = 960;

var numRoutes = {min:0, max:2};

var nodeColors = d3.scale.ordinal()
    .range(colorbrewer.Set1[9]);
    //d3.scale.category20();
var routeColors = d3.scale.linear()
    .domain([numRoutes.min, numRoutes.max])
    .range(["black", "steelblue"])
    .interpolate(d3.interpolateLab);
var tripColors = d3.scale.linear()
    .domain([numRoutes.min, numRoutes.max])
    .range(["black", "red"])
    .interpolate(d3.interpolateLab);
/*
var force = d3.layout.force()
    .charge(-120)
    .linkDistance(30)
    .size([width, height]);
*/
var tiler = d3.geo.tile()
    .size([width, height]);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var projection = d3.geo.mercator()
    //.rotate([122.2, 0, 0])
    .center([-122.3491, 47.6204])
    //.parallels([47.0, 49.0])
    .scale(500000)
    //.scale((1 << 15) / 2 / Math.PI)
var path = d3.geo.path()
    .projection(projection);

var txtFile = new XMLHttpRequest();
txtFile.open("GET", "seattle_neighborhoods/files", true);
txtFile.onreadystatechange = function()
{
  if (txtFile.readyState === 4) {  // document is ready to parse.
    if (txtFile.status === 200) {  // file is found
      allText = txtFile.responseText; 
      seattle_neighborhoods = txtFile.responseText.split("\n");
      seattle_neighborhoods.forEach(function(n) {
        d3.json("seattle_neighborhoods/"+n, function(collection) {
          svg.select("g") //.selectAll('path')
            //.datum(collection)
            .append('path')
            .datum(collection)
            .attr('d', d3.geo.path().projection(projection))
            .style('fill', '#eee')
            .style('fill-opacity', 0.2)
            .style('stroke', '#eee')
            .style('stroke-width', '0.75px');
        });
      })
    }
  }
}
txtFile.send(null);

//*
svg.selectAll("g")
    .data(tiler
      .scale(projection.scale() * 2 * Math.PI)
      .translate(projection([0, 0])))
  .enter().append("g")
    .each(function(d) {
      var g = d3.select(this);
      d3.json("http://" + ["a", "b", "c"][(d[0] * 31 + d[1]) % 3] + ".tile.openstreetmap.us/vectiles-highroad/" + d[2] + "/" + d[0] + "/" + d[1] + ".json", function(error, json) {
        g.selectAll("path")
            .data(json.features.sort(function(a, b) { return a.properties.sort_key - b.properties.sort_key; }))
          .enter().append("path")
            .attr("class", function(d) { return d.properties.kind; })
            .attr("d", path);
      });
    });
//*/


// load stations
d3.json("stops.json", function(error, graph) {
/*  force
      .nodes(graph.nodes)
      .links(graph.links)
      .start();
*/
  var link = svg.selectAll(".link")
      .data(graph.links)
    .enter().append("line")
      .attr("class", "route")
      .attr("x1", function(d) { return projection(graph.nodes[d.source].coords.coordinates)[0]; })
      .attr("y1", function(d) { return projection(graph.nodes[d.source].coords.coordinates)[1]; })
      .attr("x2", function(d) { return projection(graph.nodes[d.target].coords.coordinates)[0]; })
      .attr("y2", function(d) { return projection(graph.nodes[d.target].coords.coordinates)[1]; })
      //.style("stroke-width", function(d) { return Math.sqrt(d.value); })
      .style("stroke", function(d) { return routeColors(d.value); });

  var node = svg.selectAll(".node")
      .data(graph.nodes)
    .enter().append("circle")
      .attr("class", "station")
      .attr("cx", function(d) { return projection(d.coords.coordinates)[0]; })
      .attr("cy", function(d) { return projection(d.coords.coordinates)[1]; })
      .attr("r", 3)
      //.style("fill", function(d) { return nodeColors(d.group); })

  node.append("title")
      .text(function(d) { return d.name; });
  link.append("title")
      .text(function(d) { return d.name; });
});

d3.json("bus_positions.json", function(error, graph) {
/*  force
      .nodes(graph.nodes)
      .links(graph.links)
      .start();
*/

var link = svg.selectAll(".link")
      .data(graph.links)
    .enter().append("line")
      .attr("class", "trip")
      .attr("x1", function(d) { return projection(graph.nodes[d.source].coords.coordinates)[0]; })
      .attr("y1", function(d) { return projection(graph.nodes[d.source].coords.coordinates)[1]; })
      .attr("x2", function(d) { return projection(graph.nodes[d.target].coords.coordinates)[0]; })
      .attr("y2", function(d) { return projection(graph.nodes[d.target].coords.coordinates)[1]; })
      //.style("stroke-width", function(d) { return Math.sqrt(d.value); })
      .style("stroke", function(d) { return tripColors(d.value); });

  var node = svg.selectAll(".node")
      .data(graph.nodes)
    .enter().append("circle")
      .attr("class", "event")
      .attr("cx", function(d) { return projection(d.coords.coordinates)[0]; })
      .attr("cy", function(d) { return projection(d.coords.coordinates)[1]; })
      .attr("r", 1)
      //.style("fill", function(d) { return nodeColors(d.group); })

  node.append("title")
      .text(function(d) { return d.name; });
  link.append("title")
      .text(function(d) { return d.name; });
});

</script>
</body>